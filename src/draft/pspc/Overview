
The Pscf::Pspc namespace implements SCFT for periodic structures on a CPU.

-----------------------------------------------------------------------------
Preliminary notes about potentially confusing patterns:

1) Use of template argument D for the dimension of space: 

Most main classes in Pscf::Pspc are templates that take the integer D as a
template parameter that represents the dimensionality of space, or the 
number of coordinates required to describe the structure. Different instances 
of each template with D=1, 2, or 3 are compiled to create codes for 1D (e.g., 
lamellar), 2D (e.g.  hexagonal), or 3D structures (e.g., BCC or gyroid).

2) Parameter files formats and inheritance from Util::ParamComposite:: 

Most main classes are subclasses of a class Util::ParamComposite, which is a 
class that provides member functions to read and write a parameter file block
in a standard hierarchichal format. The format associated with a ParamComposite
may include both individual data members with values that may be read and 
written using a iostream << and >> operators, as well as child objects that
are themselves subclasses of ParamComposite. Almost every ParamComposite
subclass implements a readParameters() that encodes the format for the 
parameter file block associated with that object. The readParameters() 
functions for higher level objects invoke those for subobjects to 
read sub-blocks of the parameter file. To see the parameter file format for
an object, read the source code of its readParameters() member function.

3) Utility Array classes:

All of the code for pscf uses a set of container templates that are defined
in the src/util/container directory in preference to either bare C arrays or
the containers that are provided in the C++ standard library (e.g., std::vector).
The most heavily used of these is an array container template DArray<T>, which
represents an array of objects of type T. Elements of a DArray can be accessed
using the subscript operator [..], as in a C array: If array is an object of 
type DArray<double> then array[3] returns a reference to a floating point 
number that is array element with index 3 (the 4th element of the array). 
References returned by the [] subscript operator can be used on either the
right-hand-side of an equals sign, where they simply provide constant values,
or on the left-hand-side of a equals sign, allowing them to be assigned new
values, as with a C array or the containers in the C++ standard library.

-----------------------------------------------------------------------------
Overview of some important classes in Pscf::Pspc::

/*
* Main system object
*
* Inheritance: Pscf::Pspc::System<D> <= Util::ParamComposite
*/
template <int D>
class System
{

  // Important functions:

  // Read the parameter file to initialize
  readParameters(std::istream& ) 

  // Read a set of w-fields (chemical potential fields)
  readWBasis(std::string filename);

  // Iteratively solve a SCFT problem.
  iterate();

  // Data members:

  Pscf::Pspc Mixture<D>   mixture      :: MDE solver for mixture

  Pscf::Mesh<D>           mesh         :: Spatial discretization mesh

  Pscf::UnitCell<D>       unitCell     :: Periodic unit cell 

  Pscf::Basis<D>          basis        :: Symmetry adapted Fourier basis

  DArray<DArray<double>>  wFields      :: array of w fields, symmetrized basis

  DArray<WField<D>>       wFieldsRgrid :: array of w fields, on r-grid

  DArray<DArray<double>>  cFields      :: array of c fields, symmetrized basis

  DArray<WField<D>>       cFieldsRgrid :: array of c fields, on r-grid

}

/*
* Modified diffusion equation (MDE) solver for a mixture.
*
* This object is a "solver" for the mixture, and a container for all the polymer 
* and solvent species in the mixture. This class provides a compute function that 
* takes an array of chemical potential fields as an argument, which is passed to
* it by the parent system. The Mixture::compute fucntion calls corresponding 
* compute function for each polymer and solvent. 
*
* Pspc::Pscf is subclass of the generic Pscf::MixtureTmpl template. This is part
* a pattern: Each "solver" in the Pscf::Pspc namespace (i.e., in the CPU code 
* for periodic systems) is a subclass of a corresponding template in the Pscf.
* This is true for mixture, polymer, solvent, and propagator solvers. The 
* implementation of the base class template attempts to include everything that 
* is the same for different implementations of SCFT, using template parameters 
* to represent data types that are implementation specific. 
*
* Inheritance: 
*
*   Pspc::Pspc::Mixture<D>  <=  Pscf::MixtureTpl<Polymer<D>, Solvent<D>>
*/
class Mixture {

   // Key functions

   // Creates association with a spatial mesh and allocates memory.
   setupMesh(Mesh& )

   // Creates association with a UnitCell.
   setupUnitCell(UnitCell& )

   /*
   * Solves the modified diffusion equation for all species.
   *
   * Solving modifies internal members of Polymer and Solvent members, and
   * individual Block members of Polymer, that store thermodynamic information
   * specific to individual molecules or individual blocks. 
   *
   * \param wFields   Array of w-field inputs in real-space (r-grid) format
   * \param cFields   Array of c-field outputs in real-space (r-grid) format
   */
   compute(DArray<WField>& wFields, DArray<CField>& cFields)

   /*
   * Computes derivatives of the free energy w/respect to unit cell parameters.
   */
   computeStress()

   // Data members:

   DArray<Pscf::Monomers>        monomers; // Array of monomer objects

   DArray<Pscf::Pspc::Polymer>   polymers; // Array of Polymer objects

   DArray<Pscf::Pspc::Solvent>   solvents; // Array of Solvent objects

}


/*
* Modified diffusion equation solver for one polymer (linear or acyclic branched)
*
* Inheritance:
*
*   Pscf::Pspc::Polymer<D> <= Pscf::PolymerTmpl::< Block<D> >
*   
*   Notes:
*
*   1) The Block<D> class defines a typedef Block::Propagator that specifies the 
*   type of the associated propagator class.
*
*   2) The Pscf::PolymerTmpl<Pscf:Pspc::Block<D>> template instance is itself
*   derived from Util::Paramcomposite and Pscf::Species.
*  
*   3) Each Block of a polymer has two associated Propagator objects, representing
*   solution of the MDE integrating in different directions. Propagators can be
*   accessed either through the parent block object or directly through a list
*   maintained in the Polymer object.
*
*   3) The initialization of PolymerTmpl within its readParameters method
*   calls a makePlan() function that creates a plan for the order in which
*   propagators must be invoked to make sure that the initial condition for
*   each is available before we attempt to solve the MDE for that block and
*   direction by time-stepping the MDE. The array of propagators maintained
*   by the parent Polymer lists them in the order in which they must be 
*   solved.
*
*/
template <int D>
class Polymer {

// Important functions

   // Solve modified diffusion equations and compute block concentrations
   void compute(DArray<WField> const & wFields);

   // Compute stress components (derivatives with respect to unit cell parameters)
   void computeStress();

   // Return a precomputed stress component
   double stress(int n);

// Important private members (inherited from PolymerTmpl<Block>)

   DArray<Pspc::Block>       blocks_;

   DArray<Pspc::Vertex>      vertices_;

   DArray<Pspc::Propagator>  propagators_;

}

/*
* Class Pscf::Pspc::Block represents one block in a block polymer.
*
* Notes:
* 
* 1) Each block owns two associated Propagator objects.
* 
* 2) The monomer type and discretization with respect to the contour variable s
* are always the same for the two child Propagator objects. Most of the data
* structures that are required to time-step the MDE for a propagator are thus
* stored in the parent Block object. As a result, the Block object provides a
* "step" function that advances the solution of the MDE by one step in the
* contour discretization. This Block::step function is called repeatedly within 
* a loop by the "solve" function of the Propagator.
*
*/
class Block{

   // Important functions

   /**
   * Sets up all data structures that depends on the w field.
   *
   * This function must be called for every block after every change in w fields,
   * e.g., every iteration of an iterative solver.
   */
   void setupSolver(WField const &w);

   /**
   * Sets up all data structures that depends on the unit cell.
   *
   * This function must be called for every block after every change in unit cell
   * parameters, e.g., every iteration of an iterative solver with a flexible 
   * unit cell, or at the beginning of the iterative solution for a rigid unit
   * cell. 
   */
   void setupUnitCell(const UnitCell& unitCell);

   /**
   * Compute one step of the solution of the MDE.
   *
   * Takes the QField at one step as one argument and outputs the QField at the
   * next as a output. This is called within a loop in the Propagator::solve
   * function, with neighboring array elements as arguments.
   */
   void step(QField const&q, QField &qNew);

   /**
   * Compute monomer concentration (volume fraction) for this block.
   *
   * This computes a Simpson rule integral with respect to contour length of the 
   * product of the two propagator solutions.
   * 
   * The prefactor is phi/(q*length) in canonical ensemble, where q is the 
   * molecular partition function and length is the overall length (i.e,. volume)
   * of the polymer in reference monomer units. This function can't be called 
   * until all propagators have been solved, because it requires knowledge of q.
   */
   computeConcentration(double prefactor);

   /**
   * Compute the contribution of this block to the stress.
   */
   computeStress(double prefactor)

   /**
   * Return precomputed value of the concentration field for this Block.
   */
   CField& cField();

   /**
   * Return precomputed value for stress component i.
   */
   double stress(int i) const;

// Important private members (inherited from BlockTmpl)

   // Pair of Propagator objects.
   // Note: Pair is an array of fixed dimension 2.
   Pair<Propagator> propagators_;

   // Concentration field contribution from monomers in this block
   CField  cField_;

   // Statistical segment length of associated monomer
   double kuhn_

}

class Propagator{

   // Typedefs: 
   typedef RField<D>  WField // chemical potential field on r-space grid
   typedef RField<D>  CField // concentration field on r-space grid
   typedef RField<D>  QField // Propagator field q(r,s) at fixed s.

   // Note: Type definitions defined in Propagator are also used throughout 
   // related Block, Polymer, Solvent, and Mixture classes.

   // Important functions

   // Solve the MDE for this block and direction.
   //
   // Implementation: Calls Block::step repeatedly within a loop
   void   solve();

   // Compute and return partition function for the molecule.
   double computeQ();

   // Return initial condition at "head" of propagator.
   const QField& head() const;

   // Return final solution at "tail" of propagator.
   const QField& head() const;

   // Return q-field at the specified integration step.
   const QField& q(int i) const;

   // Important private data members:

   DArray<QField> qFields_;

}
