Problem:

The Pspc::Block class maintains a set of auxiliary variables that would be modified
by changes in either kuhn length or block length. We need a method to correctly and
(ideally) efficiently change these.

Current design:

The current design of Block implicitly assumes that the block length and kuhn length
are set during the readParameters method and never changed thereafter. Changes in 
block length effect auxiliary variables through changes in the contour step size ds_,
assumig that we don't change the number of contour steps during a sweep. The design,
does, however, allow for changes in omega fields and unit cell parameters that would
normally occur during iteration. 

Proposed invariants (things that we can't or won't change during iteration or sweep):

   Mesh - spatial discretization 
   ns_  - number of contour steps per block

Relevant private data structures:

   ds_               (depends on length, for fixed ns_, given by length/double(ns_-1)

   expKsq, expKsq2 -  exp(-|G|^2 kuhn^2 ds / 6) (depends on kuhn, ds_, and unit cell)
   expW,   expW2   -  exp(-W ds)                (depends on ds_ and w-field)
   
Relevant functions:

  BlockDescriptor::setLength    : just resets private variable length_ 
  BlockTmpl::kuhn               : just resets private variable kuhn_ 

  Block<D>::setupUnitCell       : Recomputes expKsq, expKsq2
  Block<D>::setupSolver         : Recomputes expW, expW2

  Polymer<D>::compute           : calls Block::setupSolver for all blocks before solving.
  Polymer<D>::setupUnitCell     : calls setupUnitCell for all blocks

  Note: Because Polymer<D>::compute always calls Block<D>::setupSolver for every block
  before calling the solve function for propagator, we don't need to worry about changes
  in expW and expW2 caused by changes in ds_ - these will be updated automatically 
  before the propagator solver is called, as long as ds_ is updated when we change 
  length. We do, however, need to add calls to Block<D>::setupUnitCell to update the
  expKsq and expKsq2 arrays.

Proposed quick solution:

  (1) Reimplement virtual function BlockDescriptor::setLength in Block<D> 
      so as to reset ds_. This is completely analogous to code that was already
      already added in Fd1d::Block::setLength to implement sweeps in that code. 

  (2) Modify LinearSweepParameter<D>::set_ so as to call Block::setupUnitCell
      whenever either kuhn length or length of a block changes.
      [ For now, trigger these separately, leaving open the possibility that
        setupUnitCell could be called twice on a single block. That's okay. ]

  (3) Modify BasisFieldState<D>::setSystem state so as to call Mixture::setUnitCell
      any time the unit cell is modified. This Mixture::setUnitCell function calls
      the corresponding functions for all polymers and blocks internally. 

Longer term (to make it harder to corrupt data):

  (1) Modify System so as to only return a const reference to UnitCell, and 
  provide a System::setUnitCell function that modifies the unitCell and also
  calls Mixture::setupUnitCell(....). Call this set function both in the 
  iterator and in unit cell parameter sweeps for rigid unit cells. 

  (2) For data stored in the Block class: Provide setLength and setKuhn functions 
  that sets a private hasExpKsq flag to false to mark these quantities as corrupt.
  Prove a setupUnitCell function that stores a copy of the unitCell and also sets
  hasExpKsq as false. Then modify the setupSolver method so as to check this flag
  and compute or recompute these arrays if and only if hasExpKsq == false.  This
  just-in-time approach allows us to guarantee that we use valid data, without
  forcing any unnecessary re-computation of these quantities.

  (3) Modify the Mixture so as to only return const references to Monomer objects, 
  and add a resetKuhn(int monomerId, double value, UnitCell<D>& ) member function
  of Mixture<D> that resets a Kuhn length consistently, by resetting the Kuhn
  lengths of all relevant blocks internally.  This could call the Block::setKuhn
  function, which would in turn mark hasExpKsq = false, thus forcing later
  recomputation of quantities that depend on the Kuhn length in the setupSolver 
  function.

