Proposed Changes to Implement Solvents in PsPc::

1) Create new branch "solvent", push to github  (done)

2) In Pspc, finish implementing the Solvent class (largely done)

   class Pspc::Solvent : public SolventDescriptor
   {

      // Change typedefs to refer to those in Propagator<D>, for consistency.
      typedef typename Propagator<D>::CField Cfield
      typedef typename Propagator<D>::WField Wfield

      void setMesh(const & Mesh mesh);
      setPhi(double);
      setMu(double);

      virtual solve(const & WField wField ) = 0;

      const & CField concentration() const;

   private:

      // Concentration on real space grid (Note: CField = RField<D>)
      CField concentration_;

      // Association with Mesh object
      Mesh<D>  const * meshPtr_;

   }

3) Write iostream inserter and extractor for Pscf::SolventDescriptor

4) Modify Pscf::MixtureTmpl::readParameters to read in solvent properties.

5) Modify Pspc::Mixture::compute to include contributions from solvents
      Call compute for all solvents
      Add solvent contributions to concentrations

7) Modify Pspc::System::computeFreeEnergy to include solvent contributions
   Add loops over solvent ideal gas contributions for fHelmholtz_ and pressure_

8) Modify Pspc::System:outputThermo to include solvent contributions in output

-------------------------------------------------------------------------------
Relevant parts of current design:


namespace Pscf {

   class Species {
       enum Ensemble
       double  mu(), phi(), q()  // Scalar accessors
       Ensemble ensemble();
   protected:
       double mu_, phi_, q_;
       Ensemble ensemble_;
   }

   class SolventDescriptor : public Species
   {
   public:
      double size();
      int    monomerId()
   protected:
      double size_;
      int monomerId_;
   }

   class PolymerTmpl<Block> Species, ParamComposite {

   public: 

      typedefs for propagator and fields, defined in Block
      virtual solve();
      Accessors for blocks, vertices, propagators, etc.

   private:

      DArray<Block> blocks_;    (Note: Each block contains two propagators)

      DArray<Vertex> vertices_;

   }

   template <class TP, class TS>
   class MixtureTmpl :: public ParamComposite {

   public:

      typedef TP Polymer;
      typedef TS Solvent;

      void readParameters(....)

   private:

      DArray::Monomer  monomers_;
      DArray::Polymer  polymers_;
      DArray::Solvents solvents_;
      int nMonomer_;
      int nPolymer_;
      int nSolvent_;

   }

}

namespace Pspc {

   class Polymer :: PolymerTmpl< Block<D> > {

      setPhi(double)
      setMu(double)
      setUpUnitCell(UnitCell<D> )
      compute(DArray<WField> )
      computeStress()
      double stress(int n)

   }

   class Mixture :: PolymerTmpl<Polymer, Solvent> {

      void readParameters(...)
      void setMesh(Mesh<D> const & mesh);
      void setupUnitCell(UnitCell<D> const & unitCell);
      void compute(DArray<WField> const & wFields, DArray<CField>& cFields);
      void computeStress();

   }

   class System {

      void computeFreeEnergy();
      void outputThermo(...);

   }
}
